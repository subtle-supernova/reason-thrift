(*
 Autogenerated by Thrift Compiler (0.13.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Tutorial_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class ping_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ping_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_ping_args (iprot : Protocol.t) =
  let _str20 = new ping_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t21,_id22) = iprot#readFieldBegin in
        if _t21 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id22 with 
          | _ -> iprot#skip _t21);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str20

class ping_result =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ping_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_ping_result (iprot : Protocol.t) =
  let _str25 = new ping_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t26,_id27) = iprot#readFieldBegin in
        if _t26 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id27 with 
          | _ -> iprot#skip _t26);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str25

class add_args =
object (self)
  val mutable _num1 : Int32.t option = None
  method get_num1 = _num1
  method grab_num1 = match _num1 with None->raise (Field_empty "add_args.num1") | Some _x28 -> _x28
  method set_num1 _x28 = _num1 <- Some _x28
  method unset_num1 = _num1 <- None
  method reset_num1 = _num1 <- None

  val mutable _num2 : Int32.t option = None
  method get_num2 = _num2
  method grab_num2 = match _num2 with None->raise (Field_empty "add_args.num2") | Some _x29 -> _x29
  method set_num2 _x29 = _num2 <- Some _x29
  method unset_num2 = _num2 <- None
  method reset_num2 = _num2 <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "add_args";
    (match _num1 with None -> () | Some _v -> 
      oprot#writeFieldBegin("num1",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _num2 with None -> () | Some _v -> 
      oprot#writeFieldBegin("num2",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_add_args (iprot : Protocol.t) =
  let _str32 = new add_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t33,_id34) = iprot#readFieldBegin in
        if _t33 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id34 with 
          | 1 -> (if _t33 = Protocol.T_I32 then
              _str32#set_num1 iprot#readI32
            else
              iprot#skip _t33)
          | 2 -> (if _t33 = Protocol.T_I32 then
              _str32#set_num2 iprot#readI32
            else
              iprot#skip _t33)
          | _ -> iprot#skip _t33);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str32

class add_result =
object (self)
  val mutable _success : Int32.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "add_result.success") | Some _x35 -> _x35
  method set_success _x35 = _success <- Some _x35
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "add_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_add_result (iprot : Protocol.t) =
  let _str38 = new add_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t39,_id40) = iprot#readFieldBegin in
        if _t39 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id40 with 
          | 0 -> (if _t39 = Protocol.T_I32 then
              _str38#set_success iprot#readI32
            else
              iprot#skip _t39)
          | _ -> iprot#skip _t39);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str38

class calculate_args =
object (self)
  val mutable _logid : Int32.t option = None
  method get_logid = _logid
  method grab_logid = match _logid with None->raise (Field_empty "calculate_args.logid") | Some _x41 -> _x41
  method set_logid _x41 = _logid <- Some _x41
  method unset_logid = _logid <- None
  method reset_logid = _logid <- None

  val mutable _w : work option = None
  method get_w = _w
  method grab_w = match _w with None->raise (Field_empty "calculate_args.w") | Some _x42 -> _x42
  method set_w _x42 = _w <- Some _x42
  method unset_w = _w <- None
  method reset_w = _w <- None

  method copy =
      let _new = Oo.copy self in
      if _w <> None then
        _new#set_w self#grab_w#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "calculate_args";
    (match _logid with None -> () | Some _v -> 
      oprot#writeFieldBegin("logid",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _w with None -> () | Some _v -> 
      oprot#writeFieldBegin("w",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_calculate_args (iprot : Protocol.t) =
  let _str45 = new calculate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t46,_id47) = iprot#readFieldBegin in
        if _t46 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id47 with 
          | 1 -> (if _t46 = Protocol.T_I32 then
              _str45#set_logid iprot#readI32
            else
              iprot#skip _t46)
          | 2 -> (if _t46 = Protocol.T_STRUCT then
              _str45#set_w (read_work iprot)
            else
              iprot#skip _t46)
          | _ -> iprot#skip _t46);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str45

class calculate_result =
object (self)
  val mutable _success : Int32.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "calculate_result.success") | Some _x48 -> _x48
  method set_success _x48 = _success <- Some _x48
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ouch : invalidOperation option = None
  method get_ouch = _ouch
  method grab_ouch = match _ouch with None->raise (Field_empty "calculate_result.ouch") | Some _x49 -> _x49
  method set_ouch _x49 = _ouch <- Some _x49
  method unset_ouch = _ouch <- None
  method reset_ouch = _ouch <- None

  method copy =
      let _new = Oo.copy self in
      if _ouch <> None then
        _new#set_ouch self#grab_ouch#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "calculate_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ouch with None -> () | Some _v -> 
      oprot#writeFieldBegin("ouch",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_calculate_result (iprot : Protocol.t) =
  let _str52 = new calculate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t53,_id54) = iprot#readFieldBegin in
        if _t53 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id54 with 
          | 0 -> (if _t53 = Protocol.T_I32 then
              _str52#set_success iprot#readI32
            else
              iprot#skip _t53)
          | 1 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_ouch (read_invalidOperation iprot)
            else
              iprot#skip _t53)
          | _ -> iprot#skip _t53);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str52

class zip_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "zip_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_zip_args (iprot : Protocol.t) =
  let _str57 = new zip_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t58,_id59) = iprot#readFieldBegin in
        if _t58 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id59 with 
          | _ -> iprot#skip _t58);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str57

class zip_result =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "zip_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_zip_result (iprot : Protocol.t) =
  let _str62 = new zip_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t63,_id64) = iprot#readFieldBegin in
        if _t63 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id64 with 
          | _ -> iprot#skip _t63);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str62

class virtual iface =
object (self)
  inherit SharedService.iface
  method virtual ping : unit
  method virtual add : Int32.t option -> Int32.t option -> Int32.t
  method virtual calculate : Int32.t option -> work option -> Int32.t
  method virtual zip : unit
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  inherit SharedService.client iprot oprot as super
  val mutable seqid = 0
  method ping  = 
    self#send_ping;
    self#recv_ping
  method private send_ping  = 
    oprot#writeMessageBegin ("ping", Protocol.CALL, seqid);
    let args = new ping_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_ping  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let _ = read_ping_result iprot in
        iprot#readMessageEnd;
        ()
  method add num1 num2 = 
    self#send_add num1 num2;
    self#recv_add
  method private send_add num1 num2 = 
    oprot#writeMessageBegin ("add", Protocol.CALL, seqid);
    let args = new add_args in
      args#set_num1 num1;
      args#set_num2 num2;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_add  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_add_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "add failed: unknown result")))
  method calculate logid w = 
    self#send_calculate logid w;
    self#recv_calculate
  method private send_calculate logid w = 
    oprot#writeMessageBegin ("calculate", Protocol.CALL, seqid);
    let args = new calculate_args in
      args#set_logid logid;
      args#set_w w;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_calculate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_calculate_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ouch with None -> () | Some _v ->
            raise (InvalidOperation _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "calculate failed: unknown result")))
  method zip  = 
    self#send_zip;
  method private send_zip  = 
    oprot#writeMessageBegin ("zip", Protocol.ONEWAY, seqid);
    let args = new zip_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  inherit SharedService.processor (handler :> SharedService.iface)
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_ping (seqid, iprot, oprot) =
    let _ = read_ping_args iprot in
      iprot#readMessageEnd;
      let result = new ping_result in
        (handler#ping);
        oprot#writeMessageBegin ("ping", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_add (seqid, iprot, oprot) =
    let args = read_add_args iprot in
      iprot#readMessageEnd;
      let result = new add_result in
        result#set_success (handler#add args#get_num1 args#get_num2);
        oprot#writeMessageBegin ("add", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_calculate (seqid, iprot, oprot) =
    let args = read_calculate_args iprot in
      iprot#readMessageEnd;
      let result = new calculate_result in
        (try
          result#set_success (handler#calculate args#get_logid args#get_w);
        with
          | InvalidOperation ouch -> 
              result#set_ouch ouch
        );
        oprot#writeMessageBegin ("calculate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_zip (seqid, iprot, oprot) =
    let _ = read_zip_args iprot in
      iprot#readMessageEnd;
      (handler#zip);
      ()
  initializer
    Hashtbl.add processMap "ping" self#process_ping;
    Hashtbl.add processMap "add" self#process_add;
    Hashtbl.add processMap "calculate" self#process_calculate;
    Hashtbl.add processMap "zip" self#process_zip;
end

