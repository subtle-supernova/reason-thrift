(*
 Autogenerated by Thrift Compiler (0.13.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
module Operation = 
struct
  type t = 
    | ADD
    | SUBTRACT
    | MULTIPLY
    | DIVIDE
  let to_i = function
    | ADD -> 1l
    | SUBTRACT -> 2l
    | MULTIPLY -> 3l
    | DIVIDE -> 4l
  let of_i = function
    | 1l -> ADD
    | 2l -> SUBTRACT
    | 3l -> MULTIPLY
    | 4l -> DIVIDE
    | _ -> raise Thrift_error
end
class work =
object (self)
  val mutable _num1 : Int32.t = 0l
  method get_num1 = Some _num1
  method grab_num1 = _num1
  method set_num1 _x0 = _num1 <- _x0
  method reset_num1 = _num1 <- 0l

  val mutable _num2 : Int32.t option = None
  method get_num2 = _num2
  method grab_num2 = match _num2 with None->raise (Field_empty "work.num2") | Some _x1 -> _x1
  method set_num2 _x1 = _num2 <- Some _x1
  method unset_num2 = _num2 <- None
  method reset_num2 = _num2 <- None

  val mutable _op : Operation.t option = None
  method get_op = _op
  method grab_op = match _op with None->raise (Field_empty "work.op") | Some _x2 -> _x2
  method set_op _x2 = _op <- Some _x2
  method unset_op = _op <- None
  method reset_op = _op <- None

  val mutable _comment : string option = None
  method get_comment = _comment
  method grab_comment = match _comment with None->raise (Field_empty "work.comment") | Some _x3 -> _x3
  method set_comment _x3 = _comment <- Some _x3
  method unset_comment = _comment <- None
  method reset_comment = _comment <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Work";
    (match _num1 with 0l -> () | _v -> 
      oprot#writeFieldBegin("num1",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _num2 with None -> () | Some _v -> 
      oprot#writeFieldBegin("num2",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _op with None -> () | Some _v -> 
      oprot#writeFieldBegin("op",Protocol.T_I32,3);
      oprot#writeI32(Operation.to_i _v);
      oprot#writeFieldEnd
    );
    (match _comment with None -> () | Some _v -> 
      oprot#writeFieldBegin("comment",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_work (iprot : Protocol.t) =
  let _str6 = new work in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t7,_id8) = iprot#readFieldBegin in
        if _t7 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id8 with 
          | 1 -> (if _t7 = Protocol.T_I32 then
              _str6#set_num1 iprot#readI32
            else
              iprot#skip _t7)
          | 2 -> (if _t7 = Protocol.T_I32 then
              _str6#set_num2 iprot#readI32
            else
              iprot#skip _t7)
          | 3 -> (if _t7 = Protocol.T_I32 then
              _str6#set_op (Operation.of_i iprot#readI32)
            else
              iprot#skip _t7)
          | 4 -> (if _t7 = Protocol.T_STRING then
              _str6#set_comment iprot#readString
            else
              iprot#skip _t7)
          | _ -> iprot#skip _t7);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str6

class invalidOperation =
object (self)
  val mutable _whatOp : Int32.t option = None
  method get_whatOp = _whatOp
  method grab_whatOp = match _whatOp with None->raise (Field_empty "invalidOperation.whatOp") | Some _x10 -> _x10
  method set_whatOp _x10 = _whatOp <- Some _x10
  method unset_whatOp = _whatOp <- None
  method reset_whatOp = _whatOp <- None

  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "invalidOperation.why") | Some _x11 -> _x11
  method set_why _x11 = _why <- Some _x11
  method unset_why = _why <- None
  method reset_why = _why <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "InvalidOperation";
    (match _whatOp with None -> () | Some _v -> 
      oprot#writeFieldBegin("whatOp",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _why with None -> () | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception InvalidOperation of invalidOperation
let rec read_invalidOperation (iprot : Protocol.t) =
  let _str14 = new invalidOperation in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t15,_id16) = iprot#readFieldBegin in
        if _t15 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id16 with 
          | 1 -> (if _t15 = Protocol.T_I32 then
              _str14#set_whatOp iprot#readI32
            else
              iprot#skip _t15)
          | 2 -> (if _t15 = Protocol.T_STRING then
              _str14#set_why iprot#readString
            else
              iprot#skip _t15)
          | _ -> iprot#skip _t15);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str14

type myInteger = Int32.t

